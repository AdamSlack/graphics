#version 150
#extension GL_NV_shadow_samplers_cube : enable
//uniform float shade;//not used at present
uniform sampler2D mytexture;
uniform sampler2D mynormal;
uniform samplerCube cubemap;

//uniform vec3 ambient;//for later

in vec3 cshade;
in vec3 v_o;
in vec3 pos;
in vec3 locallight_o;
in vec3 n;
in vec3 vecTangent;
in vec3 vecBitangent;

uniform int viewType;
uniform float eta;

uniform int normalmapping;
in mat3 TBN;

in vec2 tc_out;
in vec3 POS;

out vec4 pixelcolour;

//uniform vec2 TexMapSize;

float getLOD( vec2 dtx, vec2 dty );
float frexp( float x, out float e );
vec4 bilinear(int LOD,vec2 tcoords);
vec3 manualReflect(vec3 i, vec3 n);

uniform mat3 rotation_projection;
uniform vec3 objcentre_to_eye_projected;

void main()
{
	float shadescale;
	vec3 vn,l,ln,nn,h;
	vec3 textureshade;
	vec3 normalshade;

	vec2 dtx = dFdx( tc_out );
	vec2 dty = dFdy( tc_out );

	float fLOD=getLOD(dtx,dty);
	int iLOD=int(floor(fLOD));
	float fracLOD= fLOD-iLOD;

//	textureshade = (bilinear(iLOD,tc_out)*(1.0-fracLOD)+bilinear(iLOD+1,tc_out)*fracLOD).rgb;
//	textureshade = bilinear(iLOD,tc_out).rgb;
//	textureshade=texelFetch(mytexture,ivec2(tc_out)>>iLOD,iLOD).rgb;

	textureshade = texelFetch(mytexture,ivec2(tc_out),0).rgb;
	normalshade  = (normalize(texelFetch(mynormal,ivec2(tc_out),0).rgb) * 2 ) - 1;

	vec3 tempShade = vec3(0.5f, 0.5f, 0.5f);
	
	vec3 tn;
	tn.x = dot(vecTangent, normalshade);
	tn.y = dot(vecBitangent, normalshade);
	tn.z = dot(n, normalshade);

	
	//tn = normalize(tn);
	//tn = normalize(TBN * normalshade);
	tn = normalize(normalshade);
	vec3 tn_o = TBN*tn;

	vec3 tn_l;
	tn_l.x = dot(vecTangent, locallight_o);
	tn_l.y = dot(vecBitangent, locallight_o);
	tn_l.z = dot(rotation_projection*n, locallight_o);

	vec3 tn_v;
	tn_v.x = dot(vecTangent, v_o);
	tn_v.y = dot(vecBitangent, v_o);
	tn_v.z = dot(n, v_o);

	vn=normalize(tn_v);
	//vn=normalize(v_o);
  	//ln=normalize(locallight_o);

	h=vn-ln;//light direction shines from source to object
    h=normalize(h); 
    nn=normalize(n);
    shadescale= dot(h,tn);//inward normal

    if (shadescale<0){
		shadescale=0;
	}
    shadescale*=shadescale;
	shadescale*=shadescale;

	float diffuseshadescale=dot(transpose(TBN)*-ln,tn);
	if (diffuseshadescale<0)diffuseshadescale=0;
	

	///
	///	Reflection
	///
	vec3 reflected = normalize(manualReflect(v_o, TBN*tn));// TBN*tn));
	//reflected = normalize(reflect(rotation_projection*v_o, nn ));
	//reflected = normalize( reflected );	

	///
	///	Refraction
	///
	float ratio = 1.0 /eta;
	vec3 refracted = normalize(refract(v_o, TBN*tn, ratio));// TBN*tn, ratio));
	vec3 rRefr = rotation_projection*refract(v_o, TBN*tn, eta + 0.1);
    vec3 gRefr = rotation_projection*refract(v_o, TBN*tn, eta);
    vec3 bRefr = rotation_projection*refract(v_o, TBN*tn, eta - 0.1);

	///
	/// Chromatic Abhoration.
	///
	float fresnelPower = 5.0;
	float f = ((1.0-eta) * (1.0-eta)) / ((1.0+eta) * (1.0+eta));
	float mixRatio = ( f + (1.0 - f) * pow((1.0 - dot(-v_o, TBN*tn)), fresnelPower));


	vec4 envCol;
	vec3 refrCol;
	vec3 reflCol;
	vec3 mixed;
	
	switch(viewType){
		//
		//	Reflection With Texture
		// 
		case 0:
			envCol = texture(cubemap, reflected);
			pixelcolour = vec4( envCol.rgb*shadescale+ textureshade*shadescale, 1.0 );
			break;
		//
		//	Refraction With Texture
		//
		case 1:		
			envCol = texture(cubemap, refracted);
			pixelcolour = vec4( envCol.rgb*shadescale+ textureshade*shadescale, 1.0 );
			break;
		//
		//	Reflection Without Texture
		//
		case 2:
			pixelcolour = texture(cubemap, reflected);
			break;
		//
		//	Refraction Without Texture
		//
		case 3:
			pixelcolour = texture(cubemap, refracted);
			break;
		//
		//	Refracting on diffo colours..
		//
		case 4:
			float rCol = texture(cubemap, rRefr).r;
			float gCol = texture(cubemap, gRefr).g;
			float bCol = texture(cubemap, bRefr).b;
			
			pixelcolour = vec4(rCol,gCol,bCol, 1.0);
			break;
		//
		//	Chromatic Abhoration????	
		//
		case 5:
			refrCol = vec3(texture(cubemap, refracted));
			reflCol = vec3(texture(cubemap, reflected));
			mixed = mix(refrCol, reflCol, mixRatio);
			pixelcolour = vec4(mixed, 1.0);
			break;
		//
		//
		//	No Environment Mapping, just texture and normal map
		//
		default:
			pixelcolour = vec4( envCol.rgb*shadescale+ textureshade*shadescale, 1.0 );
			break;
	}

}

vec3 manualReflect(vec3 i, vec3 n) {
	return i - 2.0 * dot(n, i) * n;
}

float frexp( float x, out float e )
{
   e = ceil( log2( x ) );
   return( x * exp2( -e ) );
}

float getLOD( vec2 dtx, vec2 dty )
{
	// Get partial derivates

	// Work out diagonals
	float fTx = dtx.x + dty.x;
	float fTy = dtx.y + dty.y;
	float fXd = fTx * fTx + fTy * fTy;
	//fXd is first diagonal distance (1,1)
	fTx = dtx.x - dty.x;
	fTy = dtx.y - dty.y;
	float fYd = fTx * fTx + fTy * fTy;
	//fYd is second diagonal distance (1,-1)

	float fpixelDiff = max( fXd, fYd );

	
	// Work out Level of Detail & compensate for not taking square root
	float LOD = log2( fpixelDiff / 2 ) / 2;

	LOD = max(LOD, 0.0);
	return (LOD);
}

vec4 bilinear(int LOD,vec2 tcoords)
{
	vec2 cscal=(tcoords)*exp2(-LOD);//get the lower value note that his will mpy x by x and y by y
	vec2 lo=floor(cscal);//get the lower value note that his will mpy x by x and y by y
	vec2 frac=cscal-lo;
	float w0=frac.x*frac.y;
	float w1=(1.0-frac.x)*frac.y;
	float w2=frac.x*(1.0-frac.y);
	float w3=(1.0-frac.x)*(1.0-frac.y);
	ivec2 cd=ivec2(lo);
	vec4 c3= texelFetch(mytexture,cd,LOD) *w3;
	cd.x+=1;//increment by 1 scaled texel
	vec4 c2= texelFetch(mytexture,cd,LOD)*w2;
	cd.y+=1;//increment by 1 scaled texel
	
	vec4 c0= texelFetch(mytexture,cd,LOD)*w0;
	cd.x-=1;//now undo the x to get the last one
	vec4 c1= texelFetch(mytexture,cd,LOD)*w1;
	return c3+c1+c2+c0;
}